TEST:

## 几个函数:
`walk` 为虚拟地址找到PTE
`mappages`为新映射装载PTE

名称以`kvm`开头的函数操作内核页表；以`uvm`开头的函数操作用户页表；其他函数用于二者。`copyout`和`copyin`复制数据到用户虚拟地址或从用户虚拟地址复制数据，这些虚拟地址作为系统调用参数提供.

在内核启动阶段，**main**（kernel/main.c）将调用**kvminit**创建内核页表。整个工作流程如下，
- 首先分配新的一页物理帧用于装载内核的根页表
- 然后调用kvmmap，在即将装载的内核页表上==建立一系列的**直接映射**==，包括I/O设备、内核代码和数据、内核空闲内存段等
- 最后再把trampoline映射到内核虚拟地址的最顶端，完成了内核页表的初始化。

**kvmmap**做的工作很简单，直接转交给mappages，让它建立内核页表中的相关映射项。

来看**mappages**:
输入是一个页表、要建立映射关系的va和pa、映射的范围大小、以及PTE的权限。
```c
int
mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
```

mappages**以页为单位**处理这些输入，调用walk为va查找最后一级页表的PTE，如果该PTE没有被占用（输入新的映射时，walk会返回有效位为0的PTE，代表没有人在使用这项映射），就用输入的pa和PTE权限，更新该PTE项并设置其有效，从而在页表中建立起新映射，反复进行直到输入的所有映射关系都被建立完成。


